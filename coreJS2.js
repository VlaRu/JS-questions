export const questions2 = [
  {qst: 'Purpose and concept of a module/module pattern',
   answ: 'The module pattern allows you to split up your code into smaller, reusable pieces.---Организация кода:,Многоразовое использование:,'
  },
  {qst: 'Types of modules (AMD, ES6, CommonJS, UMD)',
    answ: ' AMD (Asynchronous Module Definition)-Менее распространен в современной разработке JavaScript из-за появления модулей ES6.---CommonJS- CommonJS — это синхронная модульная система, используемая в основном в Node.js. Он позволяет использовать require и Module.exports для импорта и экспорта модулей.----UMD (Universal Module Definition)-UMD — это шаблон определения модуля, предназначенный для работы как со средами AMD, так и с CommonJS, а также с глобальной переменной, если ни одна из них недоступна. Он предоставляет универсальное решение для определения модулей, что делает его подходящим как для клиентских, так и для серверных сред.----ES6 Modules (ECMAScript 2015)- Они используют операторы импорта и экспорта для управления модулями. AMD: лучше всего подходит для асинхронной загрузки в среде браузера. Подходит для крупных клиентских приложений, где производительность имеет решающее значение. CommonJS: идеально подходит для разработки на стороне сервера с помощью Node.js. Просто и понятно для серверных модулей. UMD: полезно для библиотек, которым необходима совместимость в разных средах. Обеспечивает гибкость и широкую совместимость. Модули ES6: современный стандарт модулей JavaScript. Лучше всего подходит для новых проектов и поддерживается современными инструментами и браузерами.'
  },
  {qst: 'Syntax and common features (export default, named exports, exports as).',
  answ: 'export * from "x.js" ; export { name } from "x.js";'
  },
  {qst: 'Dynamic imports.',
    answ: ' динамически загружать модули только тогда, когда они необходимы, вместо того, чтобы загружать всё заранее. Это даёт очевидные преимущества в производительности ,  Данный вызов возвращает Promise, который резолвится объектом модуля  Btn.addEventListener("click", () => {import("./modules/square.js").then((Module) => {let square1 = new Module.Square()}  or import("./modules/myModule.js").then((module) => {}'
  },
  {qst: 'Callbacks and IIFE.',
  answ: 'IIFE (Immediately Invoked Function Expression) IIFE — это функциональное выражение, которое выполняется сразу после его определения. Он создает локальную область видимости, избегая загрязнения глобального пространства имен. Этот шаблон часто используется для инициализации переменных или изолированного выполнения кода.  Callbacks это функции, которые передаются в качестве аргументов другим функциям и выполняются после завершения определенной задачи. Они являются фундаментальной частью асинхронного программирования на JavaScript, особенно для обработки событий, таймеров и сетевых запросов.'
  },
  {qst: 'Limitations of callbacks (e.g., callback hell).',
    answ: 'callback hell относится к ситуации, когда несколько вложенных обратных вызовов создают сложный, трудночитаемый и трудно поддерживаемый код. Обычно это происходит, когда у вас есть несколько асинхронных операций, которые зависят друг от друга.  doTask1(() => {doTask2(() => {doTask3(() => {console.log(All tasks complete);});});});------Solutions to Callback Limitations  Несколько современных функций и шаблонов JavaScript помогают смягчить ограничения обратных вызовов: Промисы. Промисы обеспечивают более чистый способ обработки асинхронных операций с помощью таких методов, как .then(), .catch() и .finally() для создания цепочек и обработки ошибок., async/await: созданный на основе промисов, async/await обеспечивает еще более чистый и читаемый синтаксис для асинхронных операций.Используя промисы и async/await, разработчики могут избежать ада обратных вызовов, более изящно обрабатывать ошибки и писать более удобный в обслуживании асинхронный код.'
  },
  {qst: 'Function currying and partial functions.',
  answ: ''
  },
  {qst: 'new keyword functionality',
    answ: ''
  },
  {qst: 'Constructor functions and their properties',
  answ: ''
  },
  {qst: 'Public, private, and static members in OOP.',
    answ: ''
  },
  {qst: 'Class declaration and syntax.',
  answ: ''
  },
  {qst: 'Differences between class declarations and constructor functions.',
    answ: ''
  },
  {qst: 'Usage of super().',
  answ: ''
  },
  {qst: 'Properties like __proto__ and prototype',
    answ: ''
  },
  {qst: 'Using [Object.create] to define prototypes explicitly.',
  answ: ''
  },
  {qst: 'Set/Map and WeakSet/WeakMap.',
    answ: 'Set is unique collection of value, Map is a collection of unique key-value pairs , key can be of any tyype. It provides adding, removing and checking for the presense of el'
  },
  {qst: 'Error handling techniques including try..catch.',
  answ: ''
  },
  {qst: 'Understanding and implementing custom errors.',
    answ: ''
  },
  {qst: 'Promises, async/await, and the event loop.',
  answ: 'Promises- это объект, представляющий возможное завершение или неудачу асинхронной операции. Он позволяет выполнять асинхронную операцию более элегантно, чем использование обратного вызова, и предоставляет метод для обработки успеха и неудачи.....async/await -это синтаксический сахар для написания асинхронного кода синхронным способом. Функция Async возвращает обещание, и внутри асинхронной функции можно использовать ожидание, чтобы приостановить выполнение до тех пор, пока обещание не будет решено.'
  },
  {qst: 'Garbage collection basics.',
    answ: ''
  },
  {qst: 'Understanding browsers location and history API.',
  answ: ''
  },
  {qst: 'User agent parsing and platform/browser detection.',
    answ: ''
  },
  {qst: 'Parsing, reflow, repaint, and the critical rendering path.',
  answ: ''
  },
  {qst: 'Using Fetch and understanding XMLHTTPRequest.',
    answ: ''
  },
  {qst: 'Differences between setTimeout and requestAnimationFrame.',
  answ: ''
  },
  {qst: 'Understanding the module system in ES6 and TypeScript.',
    answ: ''
  },
  {qst: 'Writing efficient TypeScript using basic types, enums, interfaces, and generics,basic types,enums, type interface, differences between them,using interfaces with optional properties, read-only properties,function types,creating custom types,generic types (concept)',
  answ: ''
  },
  {qst: 'Familiarity with Creational, Structural, and Behavioral Design Patterns',
    answ: '1. Singleton Pattern:  Usage: Ensure a single instance of a class (e.g., a global state or configuration manager).Example: Creating a single instance of the API client used throughout the app.----2. Factory Pattern:Usage: Create objects without specifying the exact class of the object that will be created.Example: Implement a factory for creating different types of validators or API clients based on configuration or environment.-----3. Strategy Pattern:Usage: Define a family of algorithms, encapsulate each one, and make them interchangeable.Example: Implement different authentication strategies (e.g., password-based, OAuth) that can be swapped based on the users choice or application configuration.----4. Observer Pattern:Usage: Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.Example: Use Reacts context and hooks to notify components about authentication state changes.----5. Decorator Pattern:Usage: Attach additional responsibilities to an object dynamically.Example: Wrap components with higher-order components (HOCs) to add functionality like logging, error handling, or theming.'
  },
  {qst: 'SOLID principles and design patterns in project contexts',
  answ: '1. Принцип единой ответственности (SRP):-Определение: у класса должна быть только одна причина для изменений, то есть у него должна быть только одна работа или ответственность.Приложение:AuthProvider: этот класс должен обрабатывать только логику аутентификации.Компонент NavBar: он должен обрабатывать только отрисовку панели навигации.Утилиты проверки формы. Каждая утилита проверки (например, EmailValidation, PasswordValidation) должна фокусироваться исключительно на проверке одного аспекта входных данных.------2. Принцип открытости/закрытости (OCP) Приложение:Добавление новых методов аутентификации. Если вам нужно добавить поддержку OAuth, вы можете расширить существующую логику аутентификации, не изменяя текущий AuthProvider.Настраиваемая панель навигации. Компонент NavBar может принимать реквизиты или контекст для динамического добавления новых ссылок без изменения своего внутреннего кода.---3. Принцип замены Лискова (LSP):Определение: Объекты суперкласса должны быть заменяемы объектами подкласса, не влияя при этом на корректность программы. Приложение:Многоразовые компоненты. Такие компоненты, как кнопка или ввод, должны быть спроектированы так, чтобы любой подкласс или расширенная версия могли использоваться взаимозаменяемо, не нарушая функциональности.----4. Принцип разделения интерфейсов (ISP):Определение: Клиентов не следует заставлять зависеть от интерфейсов, которые они не используют.Приложение:Пользовательские хуки и контекст. Убедитесь, что такие хуки, как useLogin, предоставляют только методы и состояние, относящиеся к использующему их компоненту.------5. Принцип инверсии зависимостей (DIP):Определение: Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба должны зависеть от абстракций.Приложение: Использование интерфейсов для вызовов API: абстрагируйте клиент API и логику аутентификации, что позволяет легко заменять реализации (например, макет клиента API для тестирования).'
  },
  {qst: 'Agile, Scrum, Kanban, and Waterfall methodologies.',
    answ: ''
  },
  {qst: 'Project estimation techniques.',
  answ: 'Вот некоторые распространенные методы оценки проекта: ---1. Экспертная оценка Опирается на знания и опыт старших членов команды или экспертов, работавших над аналогичными проектами.Эксперты предоставляют свои оценки, основанные на их знаниях и прошлом опыте. Быстро и просто.Использует практические идеи и извлеченные уроки. Минусы: Может быть субъективным. Может привести к предвзятости, если эксперты чрезмерно оптимистичны или пессимистичны. -----2. Аналогичная оценка. Описание: для оценки текущего проекта используются исторические данные из аналогичных прошлых проектов.Сравнивает текущий проект с предыдущими, имеющими схожие характеристики. Эффективно, когда подробная информация недоступна.Может предоставить быструю оценку. Точность зависит от сходства между прошлыми и текущими проектами. Может не учитывать уникальные аспекты текущего проекта. ----3. Параметрическая оценка Использует статистические и математические модели для оценки параметров проекта на основе исторических данных. Устанавливает взаимосвязи между переменными проекта и применяет их для оценки затрат и времени. Может быть очень точной, если модель хорошо откалибрована. Масштабируется для крупных проектов. Требует точных исторических данных. данные и статистические знания. Может быть сложным в настройке и обслуживании. ------ 4. Оценка снизу вверх] Разбивает проект на более мелкие компоненты или задачи. Оценивает каждый компонент индивидуально, а затем объединяет их для получения общей оценки проекта. Подробная и всеобъемлющая. Вовлекает членов команды в процесс оценки, что приводит к более эффективному участию. Требует много времени. .Может оказаться непосильной задачей для очень больших проектов.-------5. Оценка сверху вниз Начинается с высокоуровневой оценки всего проекта и разбивает его на более мелкие компоненты.Обычно на основе общего объема и целей. Быстрая первоначальная оценка. Полезно на ранних этапах планирования проекта. Менее подробно, что может привести к неточностям. Могут быть упущены из виду важные детали отдельных задач. -------6. Трехточечная оценка. Использует три сценария для оценки каждой задачи: оптимистичный (O), пессимистический (P) и наиболее вероятный (M). Ожидаемую оценку рассчитывает по формуле: (O + 4M + P) / 6. Учитывает неопределенность. и риск.Обеспечивает более реалистичную оценку. Требует тщательного анализа для определения трех оценок. Может быть субъективным. --------------7.Planning Poker Техника совместной оценки, часто используемая в Agile-проектах. Члены команды используют карточки с числами для представления своих оценок и обсуждения различий для достижения консенсуса. Поощряет командное сотрудничество и общение. Помогает выявить различные точки зрения и предположения. Для крупных проектов может потребоваться много времени. проекты. Опирается на опыт и сотрудничество членов команды.--------------8. Анализ функциональных точек (FPA). Измеряет функциональность, предоставляемую системой, на основе взаимодействия с пользователем, входных данных, выходных данных и хранилищ данных. Преобразует эти измерения в функциональные точки для оценки размера проекта. Полезно для проектов разработки программного обеспечения.Обеспечивает стандартизированный способ измерения функциональности. Требует детальных знаний о системе. Выполнение может быть сложным и трудоемким.----------------9. Моделирование Монте-Карло Использует распределения вероятностей для моделирования различных сценариев и прогнозирования вероятных результатов. Запускает несколько симуляций для расчета вероятности различной продолжительности и стоимости проекта. Учитывает неопределенность и изменчивость. Предоставляет ряд возможных результатов с вероятностями. Требуется специализированное программное обеспечение и статистические знания.Может быть сложной в настройке.'
  },
  {qst: 'Understanding different types of testing (Integration, E2E, Performance).',
    answ: 'Виды тестирования Интеграционное тестирование- tестирует взаимодействие между различными модулями или компонентами приложения, чтобы убедиться, что они работают вместе должным образом.Цель: выявить проблемы в интерфейсах и взаимодействии между интегрированными компонентами.(JUnit, NUnit, TestNG) Сквозное (E2E) тестирование Tестирует весь поток приложения от начала до конца, моделируя реальные пользовательские сценарии.Цель: проверить правильность работы всего приложения, включая все интегрированные компоненты и внешние зависимости.(Selenium, Cypress, TestCafe.)...Тестирование производительности Оценивает, как система работает с точки зрения оперативности и стабильности при определенной рабочей нагрузке.Цель: гарантировать, что приложение может обрабатывать ожидаемые и пиковые нагрузки без снижения производительности.Типы: нагрузочное тестирование, стресс-тестирование, пиковое тестирование, тестирование на выносливость.(JMeter, LoadRunner, Gatling.)'
  },
  {qst: 'Test Pyramid.',
  answ: 'Концепция: структура, иллюстрирующая идеальное распределение различных типов тестов в программном проекте. Это предполагает наличие большего количества тестов низкого уровня и меньшего количества тестов высокого уровня.----Юнит-тесты (база)Характеристики: Быстрый, изолированный и низкоуровневый. Тестируйте отдельные функции или методы. (JUnit, NUnit, Mocha.) Должно быть наибольшее количество тестов.----Сервисные/интеграционные тесты (средний)Характеристики: Проверка взаимодействия между интегрированными компонентами, более сложная, чем модульные тесты.(Spring Test, REST Assured.)Количество: меньше, чем модульные тесты, но больше, чем E2E-тесты.-----Сквозные (E2E) тесты (вверху)Характеристики: Высокоуровневый, тестирует весь поток приложения, медленнее и дороже в запуске (Selenium, Cypress).Количество: Должно быть наименьшее количество тестов из-за их сложности и стоимости.'
  },
  {qst: 'Test-driven development (TDD) and behavior-driven development (BDD).',
    answ: 'test-Driven Development (TDD)процесс разработки программного обеспечения, при котором тесты пишутся до написания кода, который должен пройти тесты.Цикл:Красный: напишите тест, который завершится неудачей, поскольку функциональность еще не реализована.Зеленый: напишите минимальный код, необходимый для прохождения теста.Рефакторинг: Рефакторинг кода для улучшения его структуры без изменения его поведения.Преимущества: Обеспечивает качество кода, уменьшает количество ошибок,облегчает рефакторинг и предоставляет документацию посредством тестов.-----Behavior-Driven Development (BDD)Определение: расширение TDD, в котором особое внимание уделяется сотрудничеству между разработчиками, отделом контроля качества и нетехническими заинтересованными сторонами. Он использует естественный язык для описания поведения приложения.Цикл: Написание сценариев. Используя язык Gherkin, напишите сценарии, описывающие поведение приложения.Шаги реализации: Разработайте код, который реализует описанное поведение. Запуск тестов: выполните сценарии, чтобы проверить поведение.Инструменты: Cucumber, SpecFlow, Behave.Преимущества: улучшает взаимодействие между членами команды, обеспечивает соответствие разработки требованиям бизнеса и создает живую документацию.Понимание и применение различных типов тестирования обеспечивает всесторонний охват и помогает выявить проблемы на ранних этапах процесса разработки. Пирамида тестирования направляет распределение тестов, чтобы сбалансировать скорость и охват, в то время как TDD и BDD обеспечивают структурированные подходы к разработке, которые делают упор на тестирование и спецификацию поведения, улучшая качество кода и его соответствие бизнес-целям.'
  },
  {qst: 'Differences between HTTP and HTTPS.',
  answ:
  'HTTP Протокол, используемый для передачи гипертекста через Интернет. Это основа любого обмена данными в сети и протокол, используемый для веб-коммуникаций.HTTP небезопасен. Данные, передаваемые по протоколу HTTP, представлены в виде обычного текста и могут быть перехвачены злоумышленниками.Typically uses port 80.  HTTPS (Hypertext Transfer Protocol Secure)  расширение HTTP. Он используется для безопасной связи в компьютерной сети.HTTPS безопасен. Он использует SSL/TLS (Secure Sockets Layer/Transport Layer Security) для шифрования данных, передаваемых между клиентом и сервером.Защищает целостность и конфиденциальность данных между компьютером пользователя и сайтом. Шифрует данные для предотвращения подслушивания, фальсификации и атак'
  },
  { qst: 'Understanding HTTP methods, headers, responses, and status codes',
    answ: ' GET - Requests data from a specified resource. POST - creates resources and queries for data using conditions PUT - updates resources DELETE - removes resources from the database 100 Request received, continuing process 200 - Success 300 - Redirection 400 - User error 500 - Server error Заголовки запросов — это метаданные, которыми обмениваются клиент и сервер. Например, заголовок запроса указывает формат запроса и ответа, предоставляет информацию о статусе запроса и т. д.'
  },
  {qst: 'Concepts of RESTful APIs',
  answ: 'RESTful API — это интерфейс,для безопасного обмена информацией через Интернет  Возможность масштабирования,Гибкость, Независимость https://aws.amazon.com/ru/what-is/restful-api/'
  },
  {qst: 'Basic security concepts including CORS, XSS, and OWASP Top 10.',
    answ: 'CORS и XSS представляют собой общие проблемы веб-безопасности, CORS (Cross-Origin Resource Sharing.Функция безопасности, реализованная веб-браузерами для ограничения веб-страницам отправки запросов к домену, отличному от того, который обслуживает веб-страницу. Это обеспечивается браузером для предотвращения подделки межсайтовых запросов и кражи данных. Использование: позволяет серверам указывать, кто и как может получить доступ к их ресурсам через заголовки HTTP.Пример. Сервер может указать разрешенные домены в заголовке Access-Control-Allow-Origin.....XSS (Cross-Site Scripting)Определение: тип атаки с внедрением, при которой вредоносные сценарии внедряются на безобидные и надежные веб-сайты.Типы: Сохраненный XSS: вредоносный скрипт хранится на целевом сервере (например, в базе данных).Отраженный XSS: вредоносный сценарий отражается из веб-приложения в браузере пользователя.XSS на основе DOM: уязвимость существует в коде на стороне клиента, а не в коде на стороне сервераПрофилактика:Проверка ввода и очистка.Кодировка вывода.Использование библиотек и фреймворков безопасности......OWASP Top 10 Определение: стандартный документ для разработчиков и безопасности веб-приложений. Он представляет собой широкий консенсус относительно наиболее важных рисков безопасности веб-приложений.10 основных угроз безопасности (2021 г.):Нарушенный контроль доступа Криптографические сбои Инъекция Небезопасный дизайн Неправильная конфигурация безопасности Уязвимые и устаревшие компоненты Сбои идентификации и аутентификации Нарушения целостности программного обеспечения и данных Сбои ведения журнала безопасности и мониторинга Подделка запросов на стороне сервера (SSRF)'
  },
  { qst: 'Authentication mechanisms (JWT, OAuth).',
  answ: 'JWT и OAuth — важные механизмы для надежной аутентификации и авторизации в современных веб-сервисах....JWT (веб-токен JSON)- компактное, безопасное для URL-адресов средство представления претензий, подлежащих передаче между двумя сторонами. Он обычно используется для аутентификации и обмена информацией.Состоит из трех частей: заголовка, полезных данных и подписи.Заголовок: обычно состоит из двух частей: типа токена (JWT) и алгоритма подписи (например, HMAC SHA256).Cодержит утверждения. Утверждения — это утверждения об объекте (обычно о пользователе) и дополнительных данных.Uспользуется для проверки того, что отправитель JWT является тем, кем он себя называет, и для того, чтобы гарантировать, что сообщение не было изменено в процессе.Aутентификация в веб-приложениях без сохранения состояния (сервер не сохраняет информацию о сеансе между запросами).'
  }
]