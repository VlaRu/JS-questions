export const questions2 = [
  {qst: 'Purpose and concept of a module/module pattern',
   answ: 'The module pattern allows you to split up your code into smaller, reusable pieces.---Организация кода:,Многоразовое использование:,'
  },
  {qst: 'Types of modules (AMD, ES6, CommonJS, UMD)',
    answ: ' AMD (Asynchronous Module Definition)-Менее распространен в современной разработке JavaScript из-за появления модулей ES6.---CommonJS- CommonJS — это синхронная модульная система, используемая в основном в Node.js. Он позволяет использовать require и Module.exports для импорта и экспорта модулей.----UMD (Universal Module Definition)-UMD — это шаблон определения модуля, предназначенный для работы как со средами AMD, так и с CommonJS, а также с глобальной переменной, если ни одна из них недоступна. Он предоставляет универсальное решение для определения модулей, что делает его подходящим как для клиентских, так и для серверных сред.----ES6 Modules (ECMAScript 2015)- Они используют операторы импорта и экспорта для управления модулями. AMD: лучше всего подходит для асинхронной загрузки в среде браузера. Подходит для крупных клиентских приложений, где производительность имеет решающее значение. CommonJS: идеально подходит для разработки на стороне сервера с помощью Node.js. Просто и понятно для серверных модулей. UMD: полезно для библиотек, которым необходима совместимость в разных средах. Обеспечивает гибкость и широкую совместимость. Модули ES6: современный стандарт модулей JavaScript. Лучше всего подходит для новых проектов и поддерживается современными инструментами и браузерами.'
  },
  {qst: 'Syntax and common features (export default, named exports, exports as).',
  answ: 'export * from "x.js" ; export { name } from "x.js";'
  },
  {qst: 'Dynamic imports.',
    answ: ' динамически загружать модули только тогда, когда они необходимы, вместо того, чтобы загружать всё заранее. Это даёт очевидные преимущества в производительности ,  Данный вызов возвращает Promise, который резолвится объектом модуля  Btn.addEventListener("click", () => {import("./modules/square.js").then((Module) => {let square1 = new Module.Square()}  or import("./modules/myModule.js").then((module) => {}'
  },
  {qst: 'Callbacks and IIFE.',
  answ: 'IIFE (Immediately Invoked Function Expression) IIFE — это функциональное выражение, которое выполняется сразу после его определения. Он создает локальную область видимости, избегая загрязнения глобального пространства имен. Этот шаблон часто используется для инициализации переменных или изолированного выполнения кода.  Callbacks это функции, которые передаются в качестве аргументов другим функциям и выполняются после завершения определенной задачи. Они являются фундаментальной частью асинхронного программирования на JavaScript, особенно для обработки событий, таймеров и сетевых запросов.'
  },
  {qst: 'Limitations of callbacks (e.g., callback hell).',
    answ: 'callback hell относится к ситуации, когда несколько вложенных обратных вызовов создают сложный, трудночитаемый и трудно поддерживаемый код. Обычно это происходит, когда у вас есть несколько асинхронных операций, которые зависят друг от друга.  doTask1(() => {doTask2(() => {doTask3(() => {console.log(All tasks complete);});});});------Solutions to Callback Limitations  Несколько современных функций и шаблонов JavaScript помогают смягчить ограничения обратных вызовов: Промисы. Промисы обеспечивают более чистый способ обработки асинхронных операций с помощью таких методов, как .then(), .catch() и .finally() для создания цепочек и обработки ошибок., async/await: созданный на основе промисов, async/await обеспечивает еще более чистый и читаемый синтаксис для асинхронных операций.Используя промисы и async/await, разработчики могут избежать ада обратных вызовов, более изящно обрабатывать ошибки и писать более удобный в обслуживании асинхронный код.'
  },
  {qst: 'Function currying and partial functions.',
  answ: 'Функциональное карирование - это техника создания новых функций путем поэтапного "запоминания" аргументов исходной функции. Каждая новая функция ожидает на один аргумент меньше, чем предыдущая.------Частичные функции похожи на карирование, но они используют встроенный метод bind для создания новой функции с фиксированными значениями некоторых аргументов.----function multiply(x, y) {return x * y;}const multiplyByFive = multiply.bind(null, 5);const result = multiplyByFive(10); // (5 * 10)console.log(result);'
  },
  {qst: 'new keyword functionality',
    answ: 'The new keyword in JavaScript is used to create new objects using a constructor function-----1. Создает новый пустой объект: new Object()----2. Устанавливает прототип объекта:Затем ключевое newслово устанавливает прототип вновь созданного объекта в свойство прототипа функции-конструктора. Этот прототип действует как образец объекта, позволяя ему наследовать свойства и методы от функции-конструктора.3. Привязывает thisключевое слово:Внутри функции-конструктора ключевое thisслово относится к вновь созданному объекту. Это позволяет вам назначать свойства и методы объекту с помощью this.4. Выполняет функцию конструктора  const person1 = new Person("Alice", 30)'
  },
  {qst: 'Constructor functions and their properties',
  answ: 'Функции-конструкторы объявляются с использованием functionключевого слова, за которым следует имя с заглавной буквы (соглашение).При желании они могут принимать аргументы, представляющие начальные значения свойств объекта.Внутри функции-конструктора thisключевое слово относится к создаваемому новому объекту.Он используется для назначения свойств и методов объекту.Каждая функция-конструктор имеет встроенное свойство, называемое prototype.Этот объект-прототип служит основой для будущих объектов, создаваемых с использованием того же конструктора.Вы можете добавить в прототип свойства и методы, чтобы сделать их наследуемыми объектами, созданными с помощью конструктора.Car.prototype.getDetails = function() {return `${this.year} ${this.make} ${this.model}`;};const car2 = new Car("Toyota", "Camry", 2022);console.log(car2.getDetails());'
  },
  {qst: 'Public, private, and static members in OOP.',
    answ: 'public -  доступны из любого места вашей программы, в том числе внутри самого класса, из других классов в той же области видимости и даже снаружи пакета или модуля private-  доступны только внутри класса, в котором они определены. Они скрыты от внешнего доступа.static - ринадлежат самому классу, а не какому-либо конкретному экземпляру класса. В памяти существует только одна копия статического ,независимо от того, сколько объектов создано из класса.'
  },
  {qst: 'Class declaration and syntax.',
  answ: 'class keyword:Class name: LowerCase конструктор (необязательно): специальный метод, вызываемый при создании нового объекта. Он инициализирует свойства объекта.this keyword: Refers to the newly created object.статические методы (необязательно): методы, принадлежащие самому классу, а не отдельным объектам. Их можно вызывать без предварительного создания объекта.class Person {constructor(name, age) {this.name = name;this.age = age;}greet() {console.log("Hello, my name is " + this.name);}static createFromBirthYear(name, birthYear) {const age = new Date().getFullYear() - birthYear;return new Person(name, age);}}const person1 = new Person("Alice", 30);person1.greet(); // Output: "Hello, my name is Alice"const person2 = Person.createFromBirthYear("Bob", 1990);console.log(person2.age); // Output: 34'
  },
  {qst: 'Differences between class declarations and constructor functions.',
    answ: 'Объявления классов: используйте classключевое слово, за которым следует имя класса и фигурные скобки, {}чтобы определить тело класса.Функции-конструкторы: определяются как обычные функции, но по соглашению имеют имя с заглавной буквы (например , ). function Person(...)Объявления классов. Свойства и методы определяются непосредственно в теле класса. Вы можете использовать модификаторы доступа ( public, или ) для управления их доступностью. privatestaticФункции конструктора. Свойства обычно добавляются к прототипу объекта с помощью thisключевого слова внутри функции конструктора. В прототип также можно добавлять методы, но они не связаны напрямую с каждым экземпляром объекта.Объявления классов. Классы могут наследовать свойства и методы родительских классов с помощью extendsключевого слова. Это способствует повторному использованию кода и создает иерархию связанных объектов. Функции конструктора. Хотя вы можете моделировать наследование с помощью таких методов, как наследование прототипов, это менее просто и не предоставляет встроенных функций наследования на основе классов.Объявления классов: внутри методов объявления класса относятся к текущему экземпляру объекта. Это позволяет вам получать доступ и изменять свойства объекта. thisФункции конструктора: внутри функции конструктора относится к вновь созданному объекту, который инициализируется. Однако методы, добавленные в прототип, не имеют прямой связи с . thisthis'
  },
  {qst: 'Usage of super().',
  answ: 'используется явный вызов конструктора родительского класса. можно использовать для вызова того же метода из родительского класса.'
  },
  {qst: 'Properties like __proto__ and prototype',
    answ: ''
  },
  {qst: 'Using [Object.create] to define prototypes explicitly.',
  answ: 'Метод Object.createв JavaScript позволяет создавать новые объекты с указанным прототипом. Это дает возможность явно определить цепочку прототипов для объекта, предлагая больше контроля по сравнению с использованием только функций конструктора.const myPrototype = {name: "default name",greet: function(){console.log("Hello, my name is " + this.name);}};const person1 = Object.create(myPrototype);'
  },
  {qst: 'Set/Map and WeakSet/WeakMap.',
    answ: 'Set is unique collection of value, Map is a collection of unique key-value pairs , key can be of any type. It provides adding, removing and checking for the presense of element'
  },
  {qst: 'Error handling techniques including try..catch.',
  answ: 'tryблок: этот блок содержит код, который вы ожидаете нормально выполнять.catchблок: этот блок выполняется, если внутри tryблока возникает ошибка (исключение). Блок catchполучает объект ошибки в качестве аргумента, который предоставляет подробную информацию о произошедшей ошибке.throwоператор используется для намеренного возникновения ошибки (исключения) из вашего кода. Это может быть полезно для сигнализации о непредвиденных условиях или неверных данных. throw new Error("Age cannot be negative");finallyблок — это необязательный третий блок внутриtry...catchзаявление.Всегда выполняется,независимо от того, произошла ли ошибка вtryблокировать или нет.Этот блок обычно используется для освобождения ресурсов или выполнения задач очистки.Глобальный обработчик ошибок: window.onerrorПромисы и Async/Await:При использовании промисов вы можете прикреплять обработчики .then()и .catch()для обработки успешного завершения и ошибок соответственно:'
  },
  {qst: 'Understanding and implementing custom errors.',
    answ: 'Рекомендуемый подход к созданию пользовательских ошибок — наследование от встроенного Error  класса.class Error {constructor(message) {this.message = message;this.name = "Error"; // (different names for different built-in error classes)this.stack = <call stack>; // non-standard, but most environments support it}}class ValidationError extends Error {}'
  },
  {qst: 'Promises, async/await, and the event loop.',
  answ: 'Promises- это объект, представляющий возможное завершение или неудачу асинхронной операции. Он позволяет выполнять асинхронную операцию более элегантно, чем использование обратного вызова, и предоставляет метод для обработки успеха и неудачи.....async/await -это синтаксический сахар для написания асинхронного кода синхронным способом. Функция Async возвращает обещание, и внутри асинхронной функции можно использовать ожидание, чтобы приостановить выполнение до тех пор, пока обещание не будет решено.'
  },
  {qst: 'Garbage collection basics.',
    answ: 'Сбор мусора — это автоматизированный процесс в JavaScript, который помогает управлять использованием памяти и предотвращать ее утечки. Вот разбивка основ:1. Распределение и освобождение памяти:Когда вы создаете объекты или выделяете память в JavaScript, движок выделяет пространство в памяти для хранения данных объекта.Освобождение этой памяти вручную в JavaScript не требуется, в отличие от некоторых языков более низкого уровня.2. Роль сборщика мусора:Сборщик мусора — это встроенный механизм, который периодически запускается в фоновом режиме.Его основная задача — идентифицировать и освободить память, занятую объектами, которые больше не используются вашей программой.Это помогает предотвратить утечки памяти, которые могут возникнуть, когда объекты создаются, но не освобождаются должным образом, что приводит к исчерпанию памяти.3. Когда происходит сбор мусора?Точное время сбора мусора не является детерминированным и зависит от различных факторов, таких как:Объем выделенной памяти.Реализация движка JavaScript. Поведение программы и шаблоны использования объектов.'
  },
  {qst: 'Understanding browsers location and history API.',
  answ: 'функции для доступа и управления данными о местоположении браузера и историей навигации.The LocationAPI предоставляет способ доступа к информации о местоположении текущей веб-страницы (URL).Он предлагает свойства только для чтения для доступа к различным частям URL-адреса.включая:href:Полный URL-адрес текущей страницы.protocol:Используемый протокол (т.г.,"https:").hostname:Имя хоста или доменное имя сервера.port:Используемый номер порта (если он указан в URL-адресе).pathname:Путь к определенному ресурсу на сервере.search:Часть строки запроса URL-адреса (т.г.,"?параметр1=значение1").hash:Идентификатор хэш-фрагмента (т.г.,"#секция 1").HistoryAPI позволяет взаимодействовать с историей навигации браузера,позволяя вам:Доступ к истории просмотров (ограничен из соображений конфиденциальности).Перемещайтесь вперед и назад по стеку истории.Добавляйте новые записи в стек истории. используя следующие методы:history.back():Переход на один шаг назад в истории.history.forward():Переходит на один шаг вперед в истории.history.go(delta):Перемещается на указанное количество шагов (delta) назад (отрицательное значение) или вперед (положительное значение) в истории.Вы также можете программно изменить URL-адрес, используяhistory.pushState(data, title, url)'
  },
  {qst: 'User agent parsing and platform/browser detection.',
    answ: 'Анализ пользовательского агента и определение платформы/браузера.Основным источником информации для анализа пользовательского агента является заголовок User-Agent. Он содержит строку, идентифицирующую браузер, его версию, операционную систему и иногда даже модель устройства.Методы обнаружения платформы/браузера:условные операторы (например, ifоператоры) для доставки различного контента или стилей.if (browser.name === "Chrome") {console.log("The user is using Chrome");} else if (browser.name === "Firefox") {console.log("The user is using Firefox");}или  window.WebGLRenderingContext'
  },
  {qst: 'Parsing, reflow, repaint, and the critical rendering path.',
  answ: 'parsing- это процесс, при котором браузер берет необработанный код HTML, CSS и JavaScript с веб-страницы и преобразует его в структурированное представление, понятное браузеру.Анализ HTML: браузер создает дерево объектной модели документа (DOM), которое представляет структуру и иерархию элементов HTML на странице.Анализ CSS: браузер создает объектную модель CSS (CSSOM), которая представляет информацию о стиле, определенную в файлах CSS. reflow, -  относится к операции макета, выполняемой браузером. После анализа HTML и CSS браузеру необходимо определить размер и положение каждого элемента на странице на основе примененных стилей. Это включает в себя расчет ширины, высоты, полей, отступов и других свойств макета для каждого элемента в дереве DOM.repaint,  Перерисовка — это процесс получения информации о макете на этапе перекомпоновки и фактической прорисовки пикселей на экране. Браузер преобразует позиции и стили элементов в инструкции для видеокарты по визуализации визуального представления страницы.Перерисовка обычно происходит после завершения перекомпоновки. Однако в некоторых случаях это может произойти независимо, например, при обновлении определенного элемента, не затрагивая общий макет.critical rendering path.- это последовательность шагов, которые проходит браузер для максимально быстрого отображения исходного контента, который пользователь видит на веб-странице. Он фокусируется на минимальном HTML, CSS и JavaScript, необходимом для отображения базовой структуры и содержимого страницы.Оптимизация CRP необходима для хорошей производительности веб-страницы. Распределяя приоритеты ресурсов, необходимых для первоначального рендеринга, браузер может быстрее отобразить пользователю пригодную для использования версию страницы, даже если дополнительные ресурсы все еще загружаются и обрабатываются в фоновом режиме.'
  },
  {qst: 'Using Fetch and understanding XMLHTTPRequest.',
    answ: 'И Fetch API, и XMLHttpRequest (XHR) — это методы для выполнения асинхронных запросов из JavaScript к веб-серверам. Однако Fetch предлагает более современный, чистый и перспективный подход по сравнению со старым XHR.fetch('https://api.example.com/data').then(response => response.json()) // Parse the response as JSON.then(data => {console.log(data); // Process the data}).catch(error => {console.error(error); // Handle errors});XHR — это старый метод выполнения асинхронных запросов. Его синтаксис более подробный и требует обратных вызовов для обработки ответов и ошибок.Преимущества Fetch API:Более чистый синтаксис: Fetch использует промисы, что делает код более читабельным и простым в обслуживании.Обработка ошибок: Fetch использует .thenи .catchдля обработки ошибок, улучшая поток кода.Fetch API основан на промисах: промисы обеспечивают более чистый способ обработки асинхронных операций и объединения нескольких запросов.'
  },
  {qst: 'Differences between setTimeout and requestAnimationFrame.',
  answ: 'setTimeout: планирует выполнение функции после указанной задержкиrequestAnimationFrame -Специально разработан для планирования вызова функции перед следующей перерисовкой окна браузера. Это идеально подходит для анимации элементов и управления визуальным внешним видом веб-страницы плавным и производительным способом.'
  },
  {qst: 'Understanding the module system in ES6 and TypeScript.',
    answ: 'Модули ECMAScript (ESM): также известные как модули ES или просто модули. Это стандартная система модулей, встроенная в современные механизмы JavaScript. Он использует ключевые слова importи exportдля управления зависимостями и организации кода.Модули CommonJS (CJS): это старая система модулей, исторически используемая Node. js и некоторые другие среды. или устаревший код Он опирается на requireфункцию импорта модулей и module.exportsпредоставления функциональных возможностей для использования другими модулями.requireФункция: используется для импорта модулей из других файлов.const math = require('./math.js'); // Import the entire module module.exports: используется для предоставления функций модуля.module.exports = {add: function(x, y) {return x + y;},}'
  },
  {qst: 'Writing efficient TypeScript using basic types, enums, interfaces, and generics,basic types,enums, type interface, differences between them,using interfaces with optional properties, read-only properties,function types,creating custom types,generic types (concept)',
  answ: ''
  },
  {qst: 'Familiarity with Creational, Structural, and Behavioral Design Patterns',
    answ: '1. Singleton Pattern:  Usage: Ensure a single instance of a class (e.g., a global state or configuration manager).Example: Creating a single instance of the API client used throughout the app.----2. Factory Pattern:Usage: Create objects without specifying the exact class of the object that will be created.Example: Implement a factory for creating different types of validators or API clients based on configuration or environment.-----3. Strategy Pattern:Usage: Define a family of algorithms, encapsulate each one, and make them interchangeable.Example: Implement different authentication strategies (e.g., password-based, OAuth) that can be swapped based on the users choice or application configuration.----4. Observer Pattern:Usage: Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.Example: Use Reacts context and hooks to notify components about authentication state changes.----5. Decorator Pattern:Usage: Attach additional responsibilities to an object dynamically.Example: Wrap components with higher-order components (HOCs) to add functionality like logging, error handling, or theming.'
  },
  {qst: 'SOLID principles and design patterns in project contexts',
  answ: '1. Принцип единой ответственности (SRP):-Определение: у класса должна быть только одна причина для изменений, то есть у него должна быть только одна работа или ответственность.Приложение:AuthProvider: этот класс должен обрабатывать только логику аутентификации.Компонент NavBar: он должен обрабатывать только отрисовку панели навигации.Утилиты проверки формы. Каждая утилита проверки (например, EmailValidation, PasswordValidation) должна фокусироваться исключительно на проверке одного аспекта входных данных.------2. Принцип открытости/закрытости (OCP) Приложение:Добавление новых методов аутентификации. Если вам нужно добавить поддержку OAuth, вы можете расширить существующую логику аутентификации, не изменяя текущий AuthProvider.Настраиваемая панель навигации. Компонент NavBar может принимать реквизиты или контекст для динамического добавления новых ссылок без изменения своего внутреннего кода.---3. Принцип замены Лискова (LSP):Определение: Объекты суперкласса должны быть заменяемы объектами подкласса, не влияя при этом на корректность программы. Приложение:Многоразовые компоненты. Такие компоненты, как кнопка или ввод, должны быть спроектированы так, чтобы любой подкласс или расширенная версия могли использоваться взаимозаменяемо, не нарушая функциональности.----4. Принцип разделения интерфейсов (ISP):Определение: Клиентов не следует заставлять зависеть от интерфейсов, которые они не используют.Приложение:Пользовательские хуки и контекст. Убедитесь, что такие хуки, как useLogin, предоставляют только методы и состояние, относящиеся к использующему их компоненту.------5. Принцип инверсии зависимостей (DIP):Определение: Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба должны зависеть от абстракций.Приложение: Использование интерфейсов для вызовов API: абстрагируйте клиент API и логику аутентификации, что позволяет легко заменять реализации (например, макет клиента API для тестирования).'
  },
  {qst: 'Agile, Scrum, Kanban, and Waterfall methodologies.',
    answ: 'Agile — это широкая философия, в которой особое внимание уделяется адаптивности, итеративной разработке и постоянному совершенствованию. Приоритет отдается отзывам клиентов и коротким циклам разработки для частого предоставления работающего программного обеспечения.Сотрудничество с клиентами во время переговоров по контракту Реагирование на изменения в соответствии с планом Scrum — это популярная Agile-структура, которая использует короткие циклы разработки, называемые «спринтами» (обычно 1–4 недели), для предоставления работающих функций программного обеспечения. Он включает в себя определенные роли (владелец продукта, Scrum-мастер, команда разработчиков), церемонии (планирование спринта, ежедневный Scrum, обзор спринта, ретроспектива спринта) и артефакты (бэклог продукта, бэклог спринта, диаграмма сгорания).Канбан — это метод визуального управления рабочим процессом, который подчеркивает непрерывный поток работы. Он использует доску Канбан со столбцами, обозначающими различные этапы разработки (например, «Сделать», «В процессе», «Готово»). Задачи представлены карточками, которые перемещаются по доске по мере выполнения.«Водопад» — это традиционный последовательный подход к управлению проектами. Он следует линейному прогрессу через такие этапы, как сбор требований, проектирование, разработка, тестирование и развертывание. Каждый этап необходимо пройти, прежде чем переходить к следующему.Ключевые особенности: Четкие и определенные этапы, предварительное детальное планирование, хорошо подходит для проектов со стабильными требованиями.'
  },
  {qst: 'Project estimation techniques.',
  answ: 'Вот некоторые распространенные методы оценки проекта: ---1. Экспертная оценка Опирается на знания и опыт старших членов команды или экспертов, работавших над аналогичными проектами.Эксперты предоставляют свои оценки, основанные на их знаниях и прошлом опыте. Быстро и просто.Использует практические идеи и извлеченные уроки. Минусы: Может быть субъективным. Может привести к предвзятости, если эксперты чрезмерно оптимистичны или пессимистичны. -----2. Аналогичная оценка. Описание: для оценки текущего проекта используются исторические данные из аналогичных прошлых проектов.Сравнивает текущий проект с предыдущими, имеющими схожие характеристики. Эффективно, когда подробная информация недоступна.Может предоставить быструю оценку. Точность зависит от сходства между прошлыми и текущими проектами. Может не учитывать уникальные аспекты текущего проекта. ----3. Параметрическая оценка Использует статистические и математические модели для оценки параметров проекта на основе исторических данных. Устанавливает взаимосвязи между переменными проекта и применяет их для оценки затрат и времени. Может быть очень точной, если модель хорошо откалибрована. Масштабируется для крупных проектов. Требует точных исторических данных. данные и статистические знания. Может быть сложным в настройке и обслуживании. ------ 4. Оценка снизу вверх] Разбивает проект на более мелкие компоненты или задачи. Оценивает каждый компонент индивидуально, а затем объединяет их для получения общей оценки проекта. Подробная и всеобъемлющая. Вовлекает членов команды в процесс оценки, что приводит к более эффективному участию. Требует много времени. .Может оказаться непосильной задачей для очень больших проектов.-------5. Оценка сверху вниз Начинается с высокоуровневой оценки всего проекта и разбивает его на более мелкие компоненты.Обычно на основе общего объема и целей. Быстрая первоначальная оценка. Полезно на ранних этапах планирования проекта. Менее подробно, что может привести к неточностям. Могут быть упущены из виду важные детали отдельных задач. -------6. Трехточечная оценка. Использует три сценария для оценки каждой задачи: оптимистичный (O), пессимистический (P) и наиболее вероятный (M). Ожидаемую оценку рассчитывает по формуле: (O + 4M + P) / 6. Учитывает неопределенность. и риск.Обеспечивает более реалистичную оценку. Требует тщательного анализа для определения трех оценок. Может быть субъективным. --------------7.Planning Poker Техника совместной оценки, часто используемая в Agile-проектах. Члены команды используют карточки с числами для представления своих оценок и обсуждения различий для достижения консенсуса. Поощряет командное сотрудничество и общение. Помогает выявить различные точки зрения и предположения. Для крупных проектов может потребоваться много времени. проекты. Опирается на опыт и сотрудничество членов команды.--------------8. Анализ функциональных точек (FPA). Измеряет функциональность, предоставляемую системой, на основе взаимодействия с пользователем, входных данных, выходных данных и хранилищ данных. Преобразует эти измерения в функциональные точки для оценки размера проекта. Полезно для проектов разработки программного обеспечения.Обеспечивает стандартизированный способ измерения функциональности. Требует детальных знаний о системе. Выполнение может быть сложным и трудоемким.----------------9. Моделирование Монте-Карло Использует распределения вероятностей для моделирования различных сценариев и прогнозирования вероятных результатов. Запускает несколько симуляций для расчета вероятности различной продолжительности и стоимости проекта. Учитывает неопределенность и изменчивость. Предоставляет ряд возможных результатов с вероятностями. Требуется специализированное программное обеспечение и статистические знания.Может быть сложной в настройке.'
  },
  {qst: 'Understanding different types of testing (Integration, E2E, Performance).',
    answ: 'Виды тестирования Интеграционное тестирование- tестирует взаимодействие между различными модулями или компонентами приложения, чтобы убедиться, что они работают вместе должным образом.Цель: выявить проблемы в интерфейсах и взаимодействии между интегрированными компонентами.(JUnit, NUnit, TestNG) Сквозное (E2E) тестирование Tестирует весь поток приложения от начала до конца, моделируя реальные пользовательские сценарии.Цель: проверить правильность работы всего приложения, включая все интегрированные компоненты и внешние зависимости.(Selenium, Cypress, TestCafe.)...Тестирование производительности Оценивает, как система работает с точки зрения оперативности и стабильности при определенной рабочей нагрузке.Цель: гарантировать, что приложение может обрабатывать ожидаемые и пиковые нагрузки без снижения производительности.Типы: нагрузочное тестирование, стресс-тестирование, пиковое тестирование, тестирование на выносливость.(JMeter, LoadRunner, Gatling.)'
  },
  {qst: 'Test Pyramid.',
  answ: 'Концепция: структура, иллюстрирующая идеальное распределение различных типов тестов в программном проекте. Это предполагает наличие большего количества тестов низкого уровня и меньшего количества тестов высокого уровня.----Юнит-тесты (база)Характеристики: Быстрый, изолированный и низкоуровневый. Тестируйте отдельные функции или методы. (JUnit, NUnit, Mocha.) Должно быть наибольшее количество тестов.----Сервисные/интеграционные тесты (средний)Характеристики: Проверка взаимодействия между интегрированными компонентами, более сложная, чем модульные тесты.(Spring Test, REST Assured.)Количество: меньше, чем модульные тесты, но больше, чем E2E-тесты.-----Сквозные (E2E) тесты (вверху)Характеристики: Высокоуровневый, тестирует весь поток приложения, медленнее и дороже в запуске (Selenium, Cypress).Количество: Должно быть наименьшее количество тестов из-за их сложности и стоимости.'
  },
  {qst: 'Test-driven development (TDD) and behavior-driven development (BDD).',
    answ: 'test-Driven Development (TDD)процесс разработки программного обеспечения, при котором тесты пишутся до написания кода, который должен пройти тесты.Цикл:Красный: напишите тест, который завершится неудачей, поскольку функциональность еще не реализована.Зеленый: напишите минимальный код, необходимый для прохождения теста.Рефакторинг: Рефакторинг кода для улучшения его структуры без изменения его поведения.Преимущества: Обеспечивает качество кода, уменьшает количество ошибок,облегчает рефакторинг и предоставляет документацию посредством тестов.-----Behavior-Driven Development (BDD)Определение: расширение TDD, в котором особое внимание уделяется сотрудничеству между разработчиками, отделом контроля качества и нетехническими заинтересованными сторонами. Он использует естественный язык для описания поведения приложения.Цикл: Написание сценариев. Используя язык Gherkin, напишите сценарии, описывающие поведение приложения.Шаги реализации: Разработайте код, который реализует описанное поведение. Запуск тестов: выполните сценарии, чтобы проверить поведение.Инструменты: Cucumber, SpecFlow, Behave.Преимущества: улучшает взаимодействие между членами команды, обеспечивает соответствие разработки требованиям бизнеса и создает живую документацию.Понимание и применение различных типов тестирования обеспечивает всесторонний охват и помогает выявить проблемы на ранних этапах процесса разработки. Пирамида тестирования направляет распределение тестов, чтобы сбалансировать скорость и охват, в то время как TDD и BDD обеспечивают структурированные подходы к разработке, которые делают упор на тестирование и спецификацию поведения, улучшая качество кода и его соответствие бизнес-целям.'
  },
  {qst: 'Differences between HTTP and HTTPS.',
  answ:
  'HTTP Протокол, используемый для передачи гипертекста через Интернет. Это основа любого обмена данными в сети и протокол, используемый для веб-коммуникаций.HTTP небезопасен. Данные, передаваемые по протоколу HTTP, представлены в виде обычного текста и могут быть перехвачены злоумышленниками.Typically uses port 80.  HTTPS (Hypertext Transfer Protocol Secure)  расширение HTTP. Он используется для безопасной связи в компьютерной сети.HTTPS безопасен. Он использует SSL/TLS (Secure Sockets Layer/Transport Layer Security) для шифрования данных, передаваемых между клиентом и сервером.Защищает целостность и конфиденциальность данных между компьютером пользователя и сайтом. Шифрует данные для предотвращения подслушивания, фальсификации и атак'
  },
  { qst: 'Understanding HTTP methods, headers, responses, and status codes',
    answ: ' GET - Requests data from a specified resource. POST - creates resources and queries for data using conditions PUT - updates resources DELETE - removes resources from the database 100 Request received, continuing process 200 - Success 300 - Redirection 400 - User error 500 - Server error Заголовки запросов — это метаданные, которыми обмениваются клиент и сервер. Например, заголовок запроса указывает формат запроса и ответа, предоставляет информацию о статусе запроса и т. д.'
  },
  {qst: 'Concepts of RESTful APIs',
  answ: 'RESTful API — это интерфейс,для безопасного обмена информацией через Интернет  Возможность масштабирования,Гибкость, Независимость https://aws.amazon.com/ru/what-is/restful-api/'
  },
  {qst: 'Basic security concepts including CORS, XSS, and OWASP Top 10.',
    answ: 'CORS и XSS представляют собой общие проблемы веб-безопасности, CORS (Cross-Origin Resource Sharing.Функция безопасности, реализованная веб-браузерами для ограничения веб-страницам отправки запросов к домену, отличному от того, который обслуживает веб-страницу. Это обеспечивается браузером для предотвращения подделки межсайтовых запросов и кражи данных. Использование: позволяет серверам указывать, кто и как может получить доступ к их ресурсам через заголовки HTTP.Пример. Сервер может указать разрешенные домены в заголовке Access-Control-Allow-Origin.CORS (Cross-Origin Resource Sharing) — это механизм, предназначенный для обеспечения безопасности веб-приложений и позволяющий контролировать, как веб-страницы могут запрашивать ресурсы с других доменов, отличных от того, с которого была загружена текущая страница. CORS решает проблему Same-Origin Policy, которая безопасно ограничивает запросы к ресурсам на других доменах.Политика CORS определяет, какие ресурсы с других доменов могут быть запрошены и загружены в браузере. Она использует HTTP-заголовки для определения разрешенных и недопустимых операций между разными источниками.Некоторые ключевые заголовки CORS:Origin: Определяет источник (origin) запроса.Access-Control-Allow-Origin: Указывает, какие источники имеют право делать запрос на ресурс. Если значение этого заголовка равно "*", это означает, что любой источник разрешен.Access-Control-Allow-Methods: Определяет разрешенные методы HTTP для запроса (например, GET, POST).Access-Control-Allow-Headers: Определяет разрешенные заголовки HTTP.Access-Control-Allow-Credentials: Указывает, могут ли запросы включать информацию аутентификации (например, куки).Access-Control-Expose-Headers: Указывает, какие заголовки могут быть доступны в ответе.CORS предотвращает атаки, такие как Cross-Site Request Forgery (CSRF), обеспечивая контроль того, какой код на странице имеет доступ к ресурсам на других доменах......XSS (Cross-Site Scripting)Определение: тип атаки с внедрением, при которой вредоносные сценарии внедряются на безобидные и надежные веб-сайты.Типы: Сохраненный XSS: вредоносный скрипт хранится на целевом сервере (например, в базе данных).Отраженный XSS: вредоносный сценарий отражается из веб-приложения в браузере пользователя.XSS на основе DOM: уязвимость существует в коде на стороне клиента, а не в коде на стороне сервераПрофилактика:Проверка ввода и очистка.Кодировка вывода.Использование библиотек и фреймворков безопасности......OWASP Top 10 Определение: стандартный документ для разработчиков и безопасности веб-приложений. Он представляет собой широкий консенсус относительно наиболее важных рисков безопасности веб-приложений.10 основных угроз безопасности (2021 г.):Нарушенный контроль доступа Криптографические сбои Инъекция Небезопасный дизайн Неправильная конфигурация безопасности Уязвимые и устаревшие компоненты Сбои идентификации и аутентификации Нарушения целостности программного обеспечения и данных Сбои ведения журнала безопасности и мониторинга Подделка запросов на стороне сервера (SSRF)'
  },
  { qst: 'Authentication mechanisms (JWT, OAuth).',
  answ: 'JWT и OAuth — важные механизмы для надежной аутентификации и авторизации в современных веб-сервисах....JWT (веб-токен JSON)- компактное, безопасное для URL-адресов средство представления претензий, подлежащих передаче между двумя сторонами. Он обычно используется для аутентификации и обмена информацией.Состоит из трех частей: заголовка, полезных данных и подписи.Заголовок: обычно состоит из двух частей: типа токена (JWT) и алгоритма подписи (например, HMAC SHA256).Cодержит утверждения. Утверждения — это утверждения об объекте (обычно о пользователе) и дополнительных данных.Uспользуется для проверки того, что отправитель JWT является тем, кем он себя называет, и для того, чтобы гарантировать, что сообщение не было изменено в процессе.Aутентификация в веб-приложениях без сохранения состояния (сервер не сохраняет информацию о сеансе между запросами).'
  }
]